Данная программа предназначена для создании экземпляра DTO и маскировка определенных его полей по паттернам.

Стек: Java 17, Spring Boot 3.5.7, Lombok

Использование программы
-----------------------------------

1) В классе ДТО на поля, которые нужно маскировать, нужно поставить аннотацию @MaskedProperty, и указать в ней 
идентификатор паттерна маскировки (идентификаторы содержатся в enum MaskPatternType). В настоящее время 
все паттерны кроме LOCALDATE поддерживают только поля типа String, LOCALDATE поддерживает только поля типа LocalDate. 
Пример:


    @MaskedProperty(type = MaskPatternType.EMAIL)  // EMAIL - паттерн, который обрабатывает эмейлы
    private String email;    // значение должно быть эмейл, например testmail@mail.com преобразуется в t*******@m***.com


Все паттерны кроме CUSTOM уже написаны. С идентификатором CUSTOM паттерн нужно писать вручную через регекс в самом классе 
ДТО, сам CUSTOM не надо указывать, пример:

    @MaskedProperty(pattern = "(\\d{3})\\d{10}(\\d{3})", replacement = "$1**********$2")
    private String cardNumber;


2) На классы ДТО с полями, которые нужно маскировать надо поставить аннотацию @Masked. Если в ДТО есть поле с вложенным
   ДТО с полями для маскировки, на этот класс вложенного ДТО тоже нужно поставить @Masked (на сам класс, но не на поле). 
Если уровней вложенности вложенности ДТО несколько, то аннотация @Masked должна стоять на каждом уровне (даже на тех 
ДТО, в которых полей с @MaskedProperty нет). Пример:

    FirstLevelDtoClass без полей с @MaskedProperty - нужно ставить @Masked
    SecondLevelDtoClass с полями с @MaskedProperty - нужно ставить @Masked
    ThirdLevelDtoClass без полей с @MaskedProperty - нужно ставить @Masked
    FourthLevelDtoClass с полями с с @MaskedProperty - нужно ставить @Masked
    LastLevelDtoClass без полей с @MaskedProperty - не нужно ставить @Masked


3) Программа поддерживает обработку вложенных коллекций с ДТО следующих типов - List, Set, Map, Array. Имплементации 
могут быть любыми. В экземпляре с замаскированными данными будут имплементации ArrayList, HashSet, HashMap, Array. 
Коллекция должна содержать в качестве элементов экземпляры ДТО с @Masked. Не-ДТО (например просто String) в качестве
   элементов не будут замаскированы. На поле с коллекций не надо ставить никаких аннотаций. 


4) На данный момент приоритет программы - выдать ДТО с заполненными данными, а не сохранить конфиденциальность любой 
ценой. Поэтому если программа не сможет замаскировать какую-то часть полученного на вход ДТО, то она создаст и выдаст 
экземпляр ДТО в котором будет замаскированно то, что программа смогла замаскировать, и не будет незамаскированно то, 
что не смогла. Причины по которым часть данных может быть не замаскирована: 
(1) если в ДТО несколько уровней вложенности и на одном из них не будет @Masked, то все 
уровни ниже его не будут замаскированы, (2) если в ДТО неподдерживаемая коллекция (например PriorityQueue),
(3) если поле с @MaskedProperty неподдерживаемого типа, (4) если на поле нет аннотации @MaskedProperty, (5) если 
указанный в аннотации паттерн не распознает значение (например EMAIL не сможет замаскировать ФИО).


5) Значения полей, на которых не стоит @MaskedProperty, просто будут скопированы в итоговый экземпляр ДТО.


6) В программе есть дополнительный функционал - проставление флага isMasked в ДТО с @Masked. Программа будет искать вв
входящем ДТО поле isMasked с типом boolean или Boolean, и поставит флаг на true если найдет. Наличие флага или его 
значение никак не влияют на маскировку. Проставленный флаг true означает только то, что ДТО прошло через маскировщик
   (т.е. флаг станет true даже если в ДТО нет полей с @MaskedProperty или если что-то не замаскировалось).


7) Для использования программы надо использовать статический метод mask из класса Masker в классе, где требуется обработка ДТО 
маскировщиком. В метод mask нужно подать экземпляр ДТО с незамаскированными данными и он вернет другой экземпляр 
этого ДТО с замаскированными данными.


Описание программы
-----------------------------------

Все нужные классы содержатся в пакете masker. Все методы в классах статические.

**class Masker** - основной класс, он осуществляет поиск и замену значений для маскировки с помощью рефлексии. 
Обрабатывает ДТО с помощью цепочки методов **mask** -> **processRecursively** (рекурсивная обработка вложенности) ->
**createDtoMaskedInstance** (создание экземпляра замаскированного ДТО и ответвление на постановку в флага в
**setMaskedFlag**) -> **copyAndMaskFields** (проход списка полей в ДТО) -> **processFieldValue** (селектор
способа обработка поля - значение без изменений, или маскировка поля String, или ответвление на маскировку LocalDate 
в **hasMaskedProperty**, или ответвления на работу с коллекциями в **class CollectionMasker**, 
или рекурсия для обработки вложенного ДТО) -> **processStringValue** (селектор выбора метода с паттерном из 
**MaskUtils** для полей String, за поля LocalDate отвечает **hasMaskedProperty**). 

**class CollectionMasker** - содержит логику работы с коллекциями (List, Set, Map, Array). 

**enum MaskPatternType** - содержит идентификаторы паттернов маскировки. Сами методы с уже готовыми паттернами содержатся в  
классе MaskUtils. Исключение - паттерн CUSTOM, с ним паттерн нужно писать вручную через регекс в самом классе ДТО.

**@interface Masked** - аннотация @Masked, ставится на класс ДТО.

**@interface MaskedProperty** - аннотация @MaskedProperty, ставится на поле в ДТО. В качестве дефолтного значения стоит
CUSTOM чтобы можно было вручную писать кастомный паттерн в аннотации.

**class MaskUtils** - в нем находятся все методы с готовыми паттернами маскировки.


Изменение функционала:
1) Если нужно удалить постановку флага isMasked - надо удалить метод setMaskedFlag и его вызов.
2) Если нужно добавить новые паттерны для String - надо (1) написать метод для паттерна в классе MaskUtils, (2) добавить 
новое значение enum в MaskPatternType, (3) в классе Masker дополнить метод processStringValue.
3) Если нужно добавить новые паттерны для других типов полей (или изменить обработку LocaDate) - надо (1) написать 
метод для паттерна в классе MaskUtils, (2) добавить новое значение enum в MaskPatternType, 
(3) в классе Masker дополнить метод processFieldValue.